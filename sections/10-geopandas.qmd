---
title: "Spatial and Image Data Using GeoPandas"
execute:
  freeze: auto
---

## Learning Objectives

- Manipulating raster data with `rasterio`
- Manipulating vector data with `geopandas`
- Working with raster and vector data together

## Introduction

In this lesson, we'll be working with geospatial raster and vector data to do an analysis on vessel traffic in south central Alaska. If you aren't already familiar, geospatial vector data consists of points, lines, and/or polygons, which represent locations on the Earth. Geospatial vector data can have differing geometries, depending on what it is representing (eg: points for cities, lines for rivers, polygons for states.) Raster data uses a set of regularly gridded cells (or pixels) to represent geographic features.

Both geospatial vector and raster data have a coordinate reference system, which describes how the points in the dataset relate to the 3-dimensional sphereoid of Earth. A coordinate reference system contains both a datum and a projection. The datum is how you georeference your points (in 3 dimensions!) onto a spheroid. The projection is how these points are mathematically transformed to represent the georeferenced point on a flat piece of paper. All coordinate reference systems require a datum. However, some coordinate reference systems are “unprojected” (also called geographic coordinate systems). Coordinates in latitude/longitude use a geographic (unprojected) coordinate system. One of the most commonly used geographic coordinate systems is WGS 1984.

Coordinate reference systems are often referenced using a shorthand 4 digit code called an EPSG code. We'll be working with two coordinate reference systems in this lesson with the following codes:

- 3338: Alaska Albers
- 4326: WGS84 (World Geodetic System 1984), used in GPS

In this lesson, we are going to take two datasets: 

- [Alaskan commercial salmon fishing statisical areas](https://doi.org/10.5063/F1QR4VJK)
- [North Pacific and Arctic Marine Vessel Traffic Dataset](https://doi.org/10.18739/A2SQ8QJ9S)

and use them to calculate the total distance travelled by ships within each fishing area.

The high level steps will be

- read in the datasets
- reproject them so they are in the same projection
- extract a subset of the raster and vector data using a bounding box
- turn each polygon in the vector data into a raster mask
- use the masks to calculate the total distance travelled (sum of pixels) for each fishing area

## Pre-processing raster data

First we need to load in our libraries. We'll use `geopandas` for vector manipulation, `rasterio` for raster maniupulation, and `shapely` for manipulating geospatial data generally.

```{python}
import geopandas as gpd

import rasterio
import rasterio.mask
import rasterio.warp
import rasterio.plot
from rasterio import features

from shapely.geometry import box

import requests

import matplotlib.pyplot as plt
import matplotlib.ticker

import pandas as pd
import numpy as np
```

First, we'll use `requests` to download the ship traffic raster from [Kapsar et al.](https://doi.org/10.18739/A2SQ8QJ9S). We grab a one month slice from August, 2020 of a coastal subset of data with 1km resolution. To get the URL in the code chunk below, you can right click the download button for the file of interest and select "copy link address."

```{python}
url = 'https://arcticdata.io/metacat/d1/mn/v2/object/urn%3Auuid%3A6b847ab0-9a3d-4534-bf28-3a96c5fa8d72'

response = requests.get(url)
open("Coastal_2020_08.tif", "wb").write(response.content)
```

Open the raster file, plot it, and look at the metadata. We use the `with` here as a context manager. This ensures that the connection to the raster file is closed and cleaned up when we are done with it.

```{python}
with rasterio.open("Coastal_2020_08.tif") as ship_con:
    # read in raster (1st band)
    ships = ship_con.read(1)
    ships_meta = ship_con.profile

plt.imshow(ships)
print(ships_meta)
```

Now download a vector shapefile of commercial fishing districts in Alaska.


```{python}
url = 'https://knb.ecoinformatics.org/knb/d1/mn/v2/object/urn%3Auuid%3A7c942c45-1539-4d47-b429-205499f0f3e4'

response = requests.get(url)
open("Alaska_Commercial_Salmon_Boundaries.gpkg", "wb").write(response.content)

```

Read in the data

```{python}
comm = gpd.read_file("Alaska_Commercial_Salmon_Boundaries.gpkg")

comm.crs
```

The raster data is in 3338, so we need to reproject this. We use the `to_crs` method on the `comm` object to transform it from 4326 (WGS 84) to 3338 (Alaska Albers).

```{python}
comm.crs
comm_3338 = comm.to_crs("EPSG:3338")

comm_3338.plot()
```

We can create a bounding box for the area of interest, and use that to clip the original raster data to just the extent we need. We use the `box` function from `shapely` to create the bounding box, then create a `geoDataFrame` from the points, and convert the WGS 84 coordinates to the Alaska Albers projection.

```{python}
coord_box = box(-159.5, 55, -144.5, 62)

coord_box_df = gpd.GeoDataFrame(
    crs = 'EPSG:4326',
    geometry = [coord_box]).to_crs("EPSG:3338")
```

Now, we can read in raster again cropped to bounding box. We use the `mask` function from `rasterio.mask`. Note that we apply this to the connection to the raster file (`with rasterio.open(...)`), update the metadata associated with the raster, and then write it back out again.


```{python}
with rasterio.open("Coastal_2020_08.tif") as ship_con:
    out_image, out_transform = rasterio.mask.mask(ship_con, coord_box_df["geometry"], crop=True)
    out_meta = ship_con.meta
```

```{python}
out_meta.update({"driver": "GTiff",
                 "height": out_image.shape[1],
                 "width": out_image.shape[2],
                 "transform": out_transform,
                 "compress": "lzw"})

with rasterio.open("Coastal_2020_08_masked.tif", "w", **out_meta) as dest:
    dest.write(out_image)
```

### Check extents

Let's read in the clipped raster data, and make a quick plot to ensure they line up the way they should.

First we read in the cropped data again, since we'll need it later. We also save the `shape` and `transform` attributes of the raster into their own attributes.

```{python}
with rasterio.open('Coastal_2020_08_masked.tif') as ship_con:
    shape = ship_con.shape
    transform = ship_con.transform
    # read in the cropped raster (1st band only)
    ship_arr = ship_con.read(1)
    # turn no data values into actual NaNs
    ship_arr[ship_arr == ship_con.nodata] = np.nan
```


```{python}
# set up plot
fig, ax = plt.subplots(figsize=(15, 15))
# plot the raster
rasterio.plot.show(ship_arr,
                   ax=ax,
                   vmin = 0,
                   vmax = 50000,
                   transform = transform)
# plot the vector
comm_3338.plot(ax=ax, facecolor='none', edgecolor='red')
```


## Calculate total distance per fishing area

In this step, we rasterize each polygon in the shapefile, such that pixels in or touching the polygon get a value of 1, and pixels not touching it get a value of 0. Then, for each polygon, we extract the indices of the raster array that are equal to 1. We then extract the values of these indicies from the original ship traffic raster data, and calculate the sum of the values over all of those pixels.

Here is a simplified diagram of the process:

![](../images/raster-mask.png)


#### Zonal statistics over one polygon

Let's look at how this works over just one fishing area first. We use the `rasterize` method from the `features` module in `rasterio`. This takes as arguments the data to rasterize (in this case the 40th row of our dataset), the shape and transform the output raster will take (these were extracted from our raster data when we read it in). We alo set the `all_touched` argument to true, which means any pixel that touches a boundary of our vector will be burned into the mask. 

```{python}
r40 = features.rasterize(comm_3338['geometry'][40].geoms,
                                    out_shape=shape,
                                    transform=transform,
                                    all_touched=True)
```

If we have a look at a plot of our rasterized version of the single fishing district, we can see that instead of a vector, we now have a raster with the shape of the district.

```{python}
# set up plot
fig, ax = plt.subplots(figsize=(15, 15))
# plot the raster
rasterio.plot.show(r40,
                   ax=ax,
                   vmin = 0,
                   vmax = 1,
                   transform = transform)
# plot the vector
comm_3338.plot(ax=ax, facecolor='none', edgecolor='red')
```

A quick call to `np.unique` shows our unique values are 0 or 1, which is what we expect.

```{python}
np.unique(r40)
```

Finally, we need to know is the indices of the original raster where the fishing district is. We can use `np.where` to extract this information

```{python}
r40_index = np.where(r40 == 1)
print(r40_index)
```

In the last step, we'll using these indices to extract the values of the data from the fishing raster, and sum them to get a total distance travelled.

```{python}
np.nansum(ship_arr[r40_index])
```

Now that we know the individual steps, let's run this over all of the districts. First we'll create an `id` column in the vector data frame. This will help us track unique fishing districts later.

```{python}
comm_3338['id'] = range(0,len(comm_3338))
```

 For each district (with `geometry` and `id`), we run the `features.rasterize` function. If any values equal 1 (some of the districts are outside the bounds of the raster), we calculate the sum of the values of the shipping raster `r_array` based on the indicies in the raster where the district is located.

```{python}
#| results: false

distance_dict = {}
for geom, idx in zip(comm_3338['geometry'], comm_3338['id']):
    rasterized = features.rasterize(geom.geoms,
                                    out_shape=shape,
                                    transform=transform,
                                    all_touched=True)
    # only save polygons that have a non-zero value
    if any(np.unique(rasterized)) == 1:
        r_index = np.where(rasterized == 1)
        distance_dict[idx] = np.nansum(ship_arr[r_index])

```

Now we just create a data frame from that dictionary, and join it to the vector data using `pandas` operations.


```{python}
# create a data frame from the result
df = pd.DataFrame.from_dict(distance_dict,
    orient='index',
    columns=['distance'])

# extract the index of the data frame as a column to use in a join
df['id'] = df.index
distance_df['distance'] = distance_df['distance']/1000
```

Now we join the result to the original geodataframe.

```{python}
# join the sums to the original data frame
res_full = comm_3338.merge(df, on = "id", how = 'inner')
```


Finally, we can plot our result!

```{python}
fig, ax = plt.subplots(figsize=(7, 7))

ax = res_full.plot(column = "distance", legend = True, ax = ax)
fig = ax.figure
label_format = '{:,.0f}'
cb_ax = fig.axes[1]
ticks_loc = cb_ax.get_yticks().tolist()
cb_ax.yaxis.set_major_locator(matplotlib.ticker.FixedLocator(ticks_loc))
cb_ax.set_yticklabels([label_format.format(x) for x in ticks_loc])
ax.set_axis_off()
ax.set_title("Distance Traveled by Ships in Kilometers")
plt.show()
```

From here we can do any additional `geopandas` operations we might be interested in. For example, what if we want to calculate the total distance by registration area (a superset of fishing district). We can do that using `dissolve` from geopandas.


```{python}
reg_area = res_full.dissolve(by = "REGISTRATION_AREA_NAME", aggfunc = 'sum')
```


Let's have a look at the same plot as before, but this time over our aggregated data.


```{python}
fig, ax = plt.subplots(figsize=(7, 7))

ax = reg_area.plot(column = "distance", legend = True, ax = ax)
fig = ax.figure
label_format = '{:,.0f}'
cb_ax = fig.axes[1]
ticks_loc = cb_ax.get_yticks().tolist()
cb_ax.yaxis.set_major_locator(matplotlib.ticker.FixedLocator(ticks_loc))
cb_ax.set_yticklabels([label_format.format(x) for x in ticks_loc])
ax.set_axis_off()
ax.set_title("Distance Traveled by Ships in Kilometers")
plt.show()
```
